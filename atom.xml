<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://marblue.me/"/>
  <updated>2019-10-25T06:33:07.465Z</updated>
  <id>http://marblue.me/</id>
  
  <author>
    <name>Marblue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java反射学习</title>
    <link href="http://marblue.me/2019/10/25/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://marblue.me/2019/10/25/java反射学习/</id>
    <published>2019-10-25T06:32:00.000Z</published>
    <updated>2019-10-25T06:33:07.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java反射学习"><a href="#java反射学习" class="headerlink" title="java反射学习"></a>java反射学习</h1><h2 id="什么是-正-射"><a href="#什么是-正-射" class="headerlink" title="什么是[正]射"></a>什么是[正]射</h2><p>既然有反射，那么就有[正]射</p><p>一般情况下，我们要使用一个类，我们必须知道这个类它的作用，我们才实例化这个类<br><img src="https://raw.githubusercontent.com/Marblue/pic/master/20191025142610.png" alt="正射"><br>上图就是一个典型的[正]射</p><p>反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。</p><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射主要提供以下功能：</p><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法</li></ol><p>重点：是运行时而不是编译时</p><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20191025142611.png" alt="反射"><br>首先，获取类的对象实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"test.Person"</span>);</span><br></pre></td></tr></table></figure><p>然后在获取类的构造方法对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor personConstructor = clz.getConstructor();</span><br></pre></td></tr></table></figure><p>通过构造方法对象来获取反射对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object personObj = personConstructor.newInstance();</span><br></pre></td></tr></table></figure><p>如果要调用反射对象的方法的话<br>首先获取方法对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method setNameMethod = clz.getMethod(<span class="string">"setName"</span>,  String.class);</span><br><span class="line">Method getNameMethod = clz.getMethod(<span class="string">"getName"</span>);</span><br></pre></td></tr></table></figure><p>通过invoke来调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setNameMethod.invoke(personObj,<span class="string">"Ming"</span>);</span><br><span class="line">getNameMethod.invoke(personObj);</span><br></pre></td></tr></table></figure><p>这种就有点类似c++里面的显式调用dll和隐式调用dll了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java反射学习&quot;&gt;&lt;a href=&quot;#java反射学习&quot; class=&quot;headerlink&quot; title=&quot;java反射学习&quot;&gt;&lt;/a&gt;java反射学习&lt;/h1&gt;&lt;h2 id=&quot;什么是-正-射&quot;&gt;&lt;a href=&quot;#什么是-正-射&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NTLM认证</title>
    <link href="http://marblue.me/2019/08/13/NTLM%E8%AE%A4%E8%AF%81/"/>
    <id>http://marblue.me/2019/08/13/NTLM认证/</id>
    <published>2019-08-13T08:58:46.000Z</published>
    <updated>2019-08-13T09:01:34.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NTLM认证"><a href="#NTLM认证" class="headerlink" title="NTLM认证"></a>NTLM认证</h1><p>前提条件：<br>工作组环境下服务器存储着每个用户的密码hash<br>域环境下域控存储着每个用户的密码hash</p><h2 id="工作组环境下"><a href="#工作组环境下" class="headerlink" title="工作组环境下"></a>工作组环境下</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20190813165915.png" alt="Step1"><br>用户TOM先登陆工作站，输入自己的用户名和密码<br>工作站首先会缓存TOM的密码的hash值，然后丢弃TOM的密码</p><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20190813165916.png" alt="Step2"><br>首先，当TOM试图访问服务器资源的时候，他会向服务器发送一个请求，并且将自己的用户名发给服务器<br>服务器接收到请求的时候，会生成一个16位的<strong>随机数</strong>（Challenge)，这个随机数有两份，一份返回给客户端，一份留在本地<br>TOM会根据返回的随机数用自己密码的hash值加密随机数，返回给服务器<br>服务器将返回值验证成功后提供服务</p><h2 id="域环境下"><a href="#域环境下" class="headerlink" title="域环境下"></a>域环境下</h2><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20190813165917.png" alt="Step3"><br>在域环境下就多了一步，因为域环境下服务器域控存储密码hash<br>当服务器收到客户端的返回值的时候，服务器就会向域控发送一个验证请求包<br>域控根据存储的密码hash值对原始challenge进行加密，验证成功性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NTLM认证&quot;&gt;&lt;a href=&quot;#NTLM认证&quot; class=&quot;headerlink&quot; title=&quot;NTLM认证&quot;&gt;&lt;/a&gt;NTLM认证&lt;/h1&gt;&lt;p&gt;前提条件：&lt;br&gt;工作组环境下服务器存储着每个用户的密码hash&lt;br&gt;域环境下域控存储着每个用户的密码ha
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows内的kerberos认证</title>
    <link href="http://marblue.me/2019/08/13/Windows%E5%86%85%E7%9A%84kerberos%E8%AE%A4%E8%AF%81/"/>
    <id>http://marblue.me/2019/08/13/Windows内的kerberos认证/</id>
    <published>2019-08-13T08:58:27.000Z</published>
    <updated>2019-08-13T09:17:14.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows内的kerberos认证"><a href="#Windows内的kerberos认证" class="headerlink" title="Windows内的kerberos认证"></a>Windows内的kerberos认证</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>由于前置知识<code>https://marblue.me/2019/08/13/kerberos认证原理/</code>可以知道，kerberos认证有三个角色：<strong>用户</strong>、<strong>服务</strong>、<strong>kerberos</strong></p><p>在windows里面，kerberos认证主要用在域环境下，于是乎，kerberos认证三个角色就换成了：<strong>用户</strong>、<strong>服务</strong>、<strong>域控</strong></p><p>域控中负责kerberos认证是一个叫<strong>KDC（密钥分发中心）</strong>的东西，KDC又大致分为三大部分：<strong>AS（身份认证服务器）</strong>，<strong>TGS（票据发送服务器）</strong>，<strong>Account Database（账户数据库）</strong>在域的创建过程中，会自动创建一个名字叫<strong>KRBTGT</strong>账号，可以理解成为在<code>KDC</code>中的管理员，</p><p>然而kerberos认证只是解决了用户是本人而不是其他人的问题，但是没有解决用户是否有权限访问服务这个问题，为了解决这个问题，微软加入了<strong>PAC（特权属性证书）</strong>这个概念。</p><p>在PAC中包含有两个数字签名<strong>PAC_SERVER_CHECKSUM</strong>和<strong>PAC_PRIVSVR_CHECKSUM</strong>，这两个数字签名分别由<strong>Server端密码HASH</strong>和<strong>krtbtgt的 NTLM HASH</strong>加密。<strong>TGS</strong>解密之后验证签名是否正确，然后再重新构造新的PAC放在<strong>票据</strong>里返回给客户端，客户端将<strong>票据</strong>发送给服务端进行验证。<strong>服务</strong>收到<strong>票据</strong>之后解密得到PAC会将PAC的数字签名发送给<strong>KDC</strong>，<strong>KDC</strong>再进行校验然后将结果以<strong>RPC返回码</strong>的形式返回给服务。</p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p>认证的大致流程kerberos认证的初始理念大致一样，分为三块：</p><ol><li>用户与AS的交互</li><li>用户与TGS的交互</li><li>用户和服务之间的交互</li></ol><h3 id="First-of-All"><a href="#First-of-All" class="headerlink" title="First of All"></a>First of All</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20190813165926.png" alt><br>首先，用户输入用户名和密码到Client中，Client会对密码进行特定的处理，这个特定处理之后的值被称为<strong>NTLM HASH</strong></p><h3 id="The-Authentication-Service-Exchange"><a href="#The-Authentication-Service-Exchange" class="headerlink" title="The Authentication Service Exchange"></a>The Authentication Service Exchange</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20190813165929.png" alt></p><p>TOM首先发送一个由TOM的NTLM HASH加密的认证包给AS，这个认证包中包含<strong>时间戳</strong>，<strong>TOM的用户名</strong>，<strong>TOM的网络地址</strong>，以及<strong>这个包的加密类型</strong></p><p>由于<strong>KDC</strong>中有一个<strong>存储着所有用户的NTLM HASH</strong>的数据库，AS如果能根据数据库中的NTLM HASH解密TOM发来的认证包，就会返回一个返回包。这个返回包里面有两个内容，一个是由<strong>TOM的NTLM HASH加密的口令</strong>，另一个是叫做<strong>TGT</strong>的东西，也就是票据授权票。这个票据授权票<strong>由krbtgt的NTLM HASH加密</strong>，里面有<strong>口令</strong>，<strong>TOM的信息</strong>，<strong>TGT的到期时间</strong>以及<strong>TOM的用户权限</strong></p><p>==注意==：这里的口令指的是TOM与AS间特有的口令</p><h3 id="The-Ticket-Granting-Service-TGS-Exchange"><a href="#The-Ticket-Granting-Service-TGS-Exchange" class="headerlink" title="The Ticket-Granting Service (TGS) Exchange"></a>The Ticket-Granting Service (TGS) Exchange</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20190813165928.png" alt></p><p>TOM收到了AS_T这个返回包之后，用自身的NTLM HASH来解密返回包，获得一个<strong>TOM与AS间特有的口令</strong>，简称为<strong>口令AST</strong>，和<strong>TGT</strong>，当TOM要使用网络上的服务时，TOM就发给<strong>TGS</strong>一个新的认证包，这个认证包里有两个东西，一个是<strong>TGT</strong>，另一个是<strong>由口令AST加密</strong>的包含<strong>TOM的信息</strong>与<strong>时间戳</strong>的包。</p><p>TGS收到TOM发来的包，首先解密由口令AST加密的包，查看自己的网络是否有TOM请求的服务，如果有，就解密TGT，检查TGT是否过期，TOM的信息是否匹配。</p><p>如果验证成功，TGS就会发送返回包<strong>TGS_T</strong>，TGS_T里面有<strong>两个东西</strong>，一个是由<strong>口令AST加密</strong>的<strong>TOM和TGT之间特有的口令</strong>（简称为<strong>口令TGST</strong>），另一个就是票据，票据是由<strong>服务密码</strong>所加密的，里面有<strong>口令TGST</strong>，<strong>用户信息</strong>，<strong>票据有效期</strong>，<strong>用户权限</strong>，<strong>时间戳</strong>。</p><h3 id="Client-Server-Authentication-Exchange"><a href="#Client-Server-Authentication-Exchange" class="headerlink" title="Client/Server Authentication Exchange"></a>Client/Server Authentication Exchange</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20190813165927.png" alt><br>TOM发送一个认证包T_S给服务，T_S中包含着两个东西，一个是由<strong>口令TGST</strong>加密的<strong>时间戳</strong>，还有一个就是<strong>票据</strong><br>服务收到这个认证包的时候，先<strong>解密票据</strong>，<strong>查看票据是否有效</strong>，<strong>TOM是否为TOM</strong>，然后再把<strong>用户权限发给KDC</strong>，<strong>KDC再返回一个认证结果</strong>，如果TOM有权限的话，就返回一个S_T返回包给TOM，并且允许TOM使用服务。<br>该票据就会<strong>缓存</strong>在<strong>TOM的电脑内存</strong>中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows内的kerberos认证&quot;&gt;&lt;a href=&quot;#Windows内的kerberos认证&quot; class=&quot;headerlink&quot; title=&quot;Windows内的kerberos认证&quot;&gt;&lt;/a&gt;Windows内的kerberos认证&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kerberos认证原理</title>
    <link href="http://marblue.me/2019/08/13/kerberos%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/"/>
    <id>http://marblue.me/2019/08/13/kerberos认证原理/</id>
    <published>2019-08-13T08:46:31.000Z</published>
    <updated>2019-08-13T08:47:15.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kerberos认证原理"><a href="#kerberos认证原理" class="headerlink" title="kerberos认证原理"></a>kerberos认证原理</h1><h2 id="几个约定"><a href="#几个约定" class="headerlink" title="几个约定"></a>几个约定</h2><ol><li>人有密码、服务有密码</li><li>kerberos中存储着所有人和服务的密码</li><li>票据可以重用</li></ol><h2 id="大致认证流程"><a href="#大致认证流程" class="headerlink" title="大致认证流程"></a>大致认证流程</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/20.png" alt="Step1"><br>主机发送：我要使用邮件服务器<br>kerberos回应：表明身份<br>主机发送TOM（当前使用的用户的用户名）<br>kerberos发回一个由TOM的密码加密的一个包，这个包里面有一个<strong>票据授权票</strong><br>这时候TOM在本地输入自己的密码，就可以正确解密包，获得票据授权票</p><p><strong>PS. 票据授权票特可以重复使用</strong></p><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/6.53.51.png" alt="Step2"><br>TOM申请使用邮件服务，并且将票据授权票给kerberos<br>kerberos返回一个口令和一个邮件服务票据<br>TOM使用口令生成一个由口令加密而成的验证器</p><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p><img src="https://raw.githubusercontent.com/Marblue/pic/master/7.07.14.png" alt="Step3"><br>TOM把邮件服务票据和验证器发给邮件服务器<br>邮件服务器首先用邮件服务密码解密票据，验证TOM身份和验证票据有效性以及获取口令<br>如果都验证成功，邮件服务器返回一个由口令加密的返回包<br>TOM收到返回包并且使用口令对返回包进行解码，验证是否真的是邮件服务器发回来的返回包，如果是真的，就使用邮件服务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kerberos认证原理&quot;&gt;&lt;a href=&quot;#kerberos认证原理&quot; class=&quot;headerlink&quot; title=&quot;kerberos认证原理&quot;&gt;&lt;/a&gt;kerberos认证原理&lt;/h1&gt;&lt;h2 id=&quot;几个约定&quot;&gt;&lt;a href=&quot;#几个约定&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
