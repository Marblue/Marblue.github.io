{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Marblue","url":"http://marblue.me","root":"/"},"pages":[{"title":"[404]","date":"2019-08-13T01:52:32.270Z","updated":"2019-08-13T01:52:32.270Z","comments":true,"path":"404.html","permalink":"http://marblue.me/404.html","excerpt":"","text":""},{"title":"关于我","date":"2019-08-13T02:49:37.563Z","updated":"2019-08-13T02:49:37.562Z","comments":true,"path":"about/index.html","permalink":"http://marblue.me/about/index.html","excerpt":"","text":"成都信息工程大学在读，chaitin科技实习中，一个卑微web狗 摸鱼 吃"}],"posts":[{"title":"NTLM认证","slug":"NTLM认证","date":"2019-08-13T08:58:46.000Z","updated":"2019-08-13T09:01:34.632Z","comments":true,"path":"2019/08/13/NTLM认证/","link":"","permalink":"http://marblue.me/2019/08/13/NTLM认证/","excerpt":"","text":"NTLM认证前提条件：工作组环境下服务器存储着每个用户的密码hash域环境下域控存储着每个用户的密码hash 工作组环境下Step1用户TOM先登陆工作站，输入自己的用户名和密码工作站首先会缓存TOM的密码的hash值，然后丢弃TOM的密码 Step2首先，当TOM试图访问服务器资源的时候，他会向服务器发送一个请求，并且将自己的用户名发给服务器服务器接收到请求的时候，会生成一个16位的随机数（Challenge)，这个随机数有两份，一份返回给客户端，一份留在本地TOM会根据返回的随机数用自己密码的hash值加密随机数，返回给服务器服务器将返回值验证成功后提供服务 域环境下在域环境下就多了一步，因为域环境下服务器域控存储密码hash当服务器收到客户端的返回值的时候，服务器就会向域控发送一个验证请求包域控根据存储的密码hash值对原始challenge进行加密，验证成功性","categories":[],"tags":[]},{"title":"Windows内的kerberos认证","slug":"Windows内的kerberos认证","date":"2019-08-13T08:58:27.000Z","updated":"2019-08-13T09:17:14.392Z","comments":true,"path":"2019/08/13/Windows内的kerberos认证/","link":"","permalink":"http://marblue.me/2019/08/13/Windows内的kerberos认证/","excerpt":"","text":"Windows内的kerberos认证前置知识由于前置知识https://marblue.me/2019/08/13/kerberos认证原理/可以知道，kerberos认证有三个角色：用户、服务、kerberos 在windows里面，kerberos认证主要用在域环境下，于是乎，kerberos认证三个角色就换成了：用户、服务、域控 域控中负责kerberos认证是一个叫KDC（密钥分发中心）的东西，KDC又大致分为三大部分：AS（身份认证服务器），TGS（票据发送服务器），Account Database（账户数据库）在域的创建过程中，会自动创建一个名字叫KRBTGT账号，可以理解成为在KDC中的管理员， 然而kerberos认证只是解决了用户是本人而不是其他人的问题，但是没有解决用户是否有权限访问服务这个问题，为了解决这个问题，微软加入了PAC（特权属性证书）这个概念。 在PAC中包含有两个数字签名PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM，这两个数字签名分别由Server端密码HASH和krtbtgt的 NTLM HASH加密。TGS解密之后验证签名是否正确，然后再重新构造新的PAC放在票据里返回给客户端，客户端将票据发送给服务端进行验证。服务收到票据之后解密得到PAC会将PAC的数字签名发送给KDC，KDC再进行校验然后将结果以RPC返回码的形式返回给服务。 认证流程认证的大致流程kerberos认证的初始理念大致一样，分为三块： 用户与AS的交互 用户与TGS的交互 用户和服务之间的交互 First of All首先，用户输入用户名和密码到Client中，Client会对密码进行特定的处理，这个特定处理之后的值被称为NTLM HASH The Authentication Service Exchange TOM首先发送一个由TOM的NTLM HASH加密的认证包给AS，这个认证包中包含时间戳，TOM的用户名，TOM的网络地址，以及这个包的加密类型 由于KDC中有一个存储着所有用户的NTLM HASH的数据库，AS如果能根据数据库中的NTLM HASH解密TOM发来的认证包，就会返回一个返回包。这个返回包里面有两个内容，一个是由TOM的NTLM HASH加密的口令，另一个是叫做TGT的东西，也就是票据授权票。这个票据授权票由krbtgt的NTLM HASH加密，里面有口令，TOM的信息，TGT的到期时间以及TOM的用户权限 ==注意==：这里的口令指的是TOM与AS间特有的口令 The Ticket-Granting Service (TGS) Exchange TOM收到了AS_T这个返回包之后，用自身的NTLM HASH来解密返回包，获得一个TOM与AS间特有的口令，简称为口令AST，和TGT，当TOM要使用网络上的服务时，TOM就发给TGS一个新的认证包，这个认证包里有两个东西，一个是TGT，另一个是由口令AST加密的包含TOM的信息与时间戳的包。 TGS收到TOM发来的包，首先解密由口令AST加密的包，查看自己的网络是否有TOM请求的服务，如果有，就解密TGT，检查TGT是否过期，TOM的信息是否匹配。 如果验证成功，TGS就会发送返回包TGS_T，TGS_T里面有两个东西，一个是由口令AST加密的TOM和TGT之间特有的口令（简称为口令TGST），另一个就是票据，票据是由服务密码所加密的，里面有口令TGST，用户信息，票据有效期，用户权限，时间戳。 Client/Server Authentication ExchangeTOM发送一个认证包T_S给服务，T_S中包含着两个东西，一个是由口令TGST加密的时间戳，还有一个就是票据服务收到这个认证包的时候，先解密票据，查看票据是否有效，TOM是否为TOM，然后再把用户权限发给KDC，KDC再返回一个认证结果，如果TOM有权限的话，就返回一个S_T返回包给TOM，并且允许TOM使用服务。该票据就会缓存在TOM的电脑内存中","categories":[],"tags":[]},{"title":"kerberos认证原理","slug":"kerberos认证原理","date":"2019-08-13T08:46:31.000Z","updated":"2019-08-13T08:47:15.104Z","comments":true,"path":"2019/08/13/kerberos认证原理/","link":"","permalink":"http://marblue.me/2019/08/13/kerberos认证原理/","excerpt":"","text":"kerberos认证原理几个约定 人有密码、服务有密码 kerberos中存储着所有人和服务的密码 票据可以重用 大致认证流程Step1主机发送：我要使用邮件服务器kerberos回应：表明身份主机发送TOM（当前使用的用户的用户名）kerberos发回一个由TOM的密码加密的一个包，这个包里面有一个票据授权票这时候TOM在本地输入自己的密码，就可以正确解密包，获得票据授权票 PS. 票据授权票特可以重复使用 Step2TOM申请使用邮件服务，并且将票据授权票给kerberoskerberos返回一个口令和一个邮件服务票据TOM使用口令生成一个由口令加密而成的验证器 Step3TOM把邮件服务票据和验证器发给邮件服务器邮件服务器首先用邮件服务密码解密票据，验证TOM身份和验证票据有效性以及获取口令如果都验证成功，邮件服务器返回一个由口令加密的返回包TOM收到返回包并且使用口令对返回包进行解码，验证是否真的是邮件服务器发回来的返回包，如果是真的，就使用邮件服务","categories":[],"tags":[]}]}