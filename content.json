{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Marblue","url":"http://marblue.me","root":"/"},"pages":[{"title":"[404]","date":"2019-08-13T01:52:32.270Z","updated":"2019-08-13T01:52:32.270Z","comments":true,"path":"404.html","permalink":"http://marblue.me/404.html","excerpt":"","text":""},{"title":"关于我","date":"2019-08-13T02:49:37.563Z","updated":"2019-08-13T02:49:37.562Z","comments":true,"path":"about/index.html","permalink":"http://marblue.me/about/index.html","excerpt":"","text":"成都信息工程大学在读，chaitin科技实习中，一个卑微web狗 摸鱼 吃"}],"posts":[{"title":"2019年终总结","slug":"2019年终总结","date":"2019-12-31T17:17:17.000Z","updated":"2019-12-31T17:19:20.834Z","comments":true,"path":"2020/01/01/2019年终总结/","link":"","permalink":"http://marblue.me/2020/01/01/2019年终总结/","excerpt":"","text":"年终总结互联网是有记忆的，记录下2019年自己干过的大大小小的蠢事 关于2019在洗澡的时候仔细的思考了2019年的我到底在干嘛。想来想去也不知道该从哪里说起，就用几首我特别喜欢的音乐来表达下吧 80后时代曲(by C allstar) 一飞冲天去，一飞冲天去，无奈送走穿梭机 “2019年对我来说真的是个特别有意思的年份，寒假的时候帮学校老师做项目，一月份的成都，个位数的温度，彻底的把我这个广东人冻成了狗。但是，当项目暂时告一段落，发钱的时候。那些在一月份所受到的苦难全部消散成过眼云烟，那时候我在想“或许这就是为什么那么多人期待着发工资这一天的原因吧” 拿着做项目发的一点点钱，过了一个普通的不能再普通的寒假，心想着“我这也算是有点小小的成功了吧”。但是随之而来的却是一个无比残酷的单选题考研还是就业 其实我很早的就意识到这个单选题的存在了，也和父母有过多次的讨论，但是我却一次次的选择了逃避，看着周围的同学不是开始各种考研复习，就是去各大互联网公司实习。下意识的也开始焦虑起来了 就像是大家在大学这个新手村花了三年时间，练成了各种绝世武功，配上了绝世神兵，准备闯荡江湖了。而我，花了三年时间，只是学了太祖长拳，却也幻想着和他们一起闯荡江湖 结果也就那样了，都还没出拳，就被现实击倒在地上，面试的几家公司不是石沉大海就是“简历已经进入人才库” 回过神来，身边的人已经“考研第x轮复习”，“提前获得转正offer”。而我，也不得不去做出属于我的选择了 可能是老天真的看不下去我这个只是学了太祖长拳出来闯荡江湖的人吧，在暑假获得了长亭科技的实习offer。我至今都忘不了收到offer那一天，当hr小姐姐把offer letter发到我的邮箱的时候，我还在清理邮箱，差点就把offer letter删掉了。。幸好手慢没删掉。或许这真的就是上天眷顾吧，能在长亭科技实习，这个是我从来没有想过的，我投简历的时候还在想，大概这又是“简历进入人才库”+1吧。不过也是感谢长亭的师傅们给我机会让我在这里实习。 Thanks Change(by Monkey Majik) I need a change ‘cause it’s all gone wrong for me 或许真的真的要到改变的时候了吧，从16年进入到学校以来，年年都是一个样子，间歇性踌躇满志，持续性混吃等死 然而19年，生活终于对我动手了，逼迫着我去做出选择，做出改变。 体重是增加了，脑袋里的知识好像不随着体重的增加而增加； 头发也开始逐渐逐渐的减少了，但是焦虑却也没随着头发的掉落也一并掉落，反而像掉落在地的头发一样越积越多。。 去年的Flag至今没实现完，学习计划也从“2018年学习计划”改成了“2019年学习计划” 或许真的是要做出一点改变了 关于工作 在寒假做项目的时候，我原以为工作的强度大多都是这样的，应该没有比这更累的了吧。结果这和实习工作比起来，简直是小巫见大巫。实习期间也算是大大小小的项目都做过了，也都记录一下吧 “doc工程师”说实话，我感觉比挖洞更麻烦的事情就是写报告了。文档工程师提醒您“报告不规范，支付宝两行泪” “守夜冠军”高强度盯着监控日志，生怕出现严重的告警，提心吊胆整个晚上。身体与心理的双重打击 “无情的挖洞机器”|“带恶人”|“今晚你加班”不说了，懂得都懂，说出来都是泪。做完这个项目我就发誓，谁再逼我做这个项目我就去提流程 关于游戏无论多苦多累，只要玩上几款好游戏，人生就感觉好起来了。但是毕竟实习了，能玩游戏时间也没有在学校那么多了。但是还是抽空玩了几款游戏 蔚蓝一款痛并快乐着的小游戏(确信)，主要讲述的是一个少女为了寻求自我去爬山，在爬山旅途中遇到的各种各样的人和物的故事。 这款游戏的代入感很强，你常常会感觉到不是少女在爬山，而是你在爬山，你在经历着这一切。 游戏好玩，操作感强，故事讲述的好，音乐又好听(重点)。强烈建议大家都去玩一玩 真的是一款特别不错的游戏，可惜受限于我的文笔，无法完整的表现出这个游戏到底有多好，真的强烈推荐大家都去玩一下 火焰纹章-风花雪月一款战棋类游戏，主要讲述的是老师与学生、学生与学生之间的事(这个是真的) 这个游戏真正吸引我的地方是它对人物的刻画，当在一个学校一起学习的同学们，为了追寻各自的目标而走上不同的道路，昔日的同学可能会变成今时的同伴，也可能变成阻拦你前进的人，这时候的你，该如何抉择。 命运2人啊，总不能呆在自己的一亩三分地里过活，总得进行社交活动，我觉得命运2其实就是一个不错的服务性游戏 也是这款游戏，让我认识到了不少朋友，也找到了一起玩的组织，或许这款游戏带来的不仅仅是游戏本身所呈现的内容，更多的是增进人与人之间的距离吧。大概 关于2020全面小康难道还要我再度重申吗？ 关于Flag还是要立点Flag的，万一实现了呢 SRC排名 更多的挖洞技巧 完善自制的工具库 挖一个高质量的CVE 最后的最后 找富婆(速度安排我，我不想努力了) 脱单(求求了，全面小康建成之日真不想再一个人跨年了) 引用一段我今天看到的话来结束吧 12345678910111213141516171819202122232425262728这一年里，你一共提交了100个漏洞报告你熱衷于使用AWVs和御剑。喜欢和沙雕网友一起讨论你们两个都不懂的技术知识。每天早上你都会打开资讯站点假装了解最新漏洞。2019年，你说的最多的几句话是这个漏洞怎么会复现不成功呢在我测试时是好的啊你清下缓存试试4.23大概是很特别的一天这一天里你提交了二十个漏洞重复了六个内部已知有十二个通过了两个低危十块钱8.17这一天你睡得很晚凌晨2:34才挖到一个低危然后在朋友圈里发了一句装逼的话挖洞好累那一刻你好像感觉自己也成为了一个大佬2019年一年的时间里你使用了5瓶霸王洗发露发际线上升了4厘米 2020年一起加油吧各位","categories":[],"tags":[]},{"title":"java反射学习","slug":"java反射学习","date":"2019-10-25T06:32:00.000Z","updated":"2019-10-25T06:33:07.465Z","comments":true,"path":"2019/10/25/java反射学习/","link":"","permalink":"http://marblue.me/2019/10/25/java反射学习/","excerpt":"","text":"java反射学习什么是[正]射既然有反射，那么就有[正]射 一般情况下，我们要使用一个类，我们必须知道这个类它的作用，我们才实例化这个类上图就是一个典型的[正]射 反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。 什么是反射反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java 反射主要提供以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法 重点：是运行时而不是编译时 首先，获取类的对象实例 1Class clz = Class.forName(\"test.Person\"); 然后在获取类的构造方法对象 1Constructor personConstructor = clz.getConstructor(); 通过构造方法对象来获取反射对象 1Object personObj = personConstructor.newInstance(); 如果要调用反射对象的方法的话首先获取方法对象 12Method setNameMethod = clz.getMethod(\"setName\", String.class);Method getNameMethod = clz.getMethod(\"getName\"); 通过invoke来调用方法 12setNameMethod.invoke(personObj,\"Ming\");getNameMethod.invoke(personObj); 这种就有点类似c++里面的显式调用dll和隐式调用dll了。","categories":[],"tags":[]},{"title":"NTLM认证","slug":"NTLM认证","date":"2019-08-13T08:58:46.000Z","updated":"2019-08-13T09:01:34.632Z","comments":true,"path":"2019/08/13/NTLM认证/","link":"","permalink":"http://marblue.me/2019/08/13/NTLM认证/","excerpt":"","text":"NTLM认证前提条件：工作组环境下服务器存储着每个用户的密码hash域环境下域控存储着每个用户的密码hash 工作组环境下Step1用户TOM先登陆工作站，输入自己的用户名和密码工作站首先会缓存TOM的密码的hash值，然后丢弃TOM的密码 Step2首先，当TOM试图访问服务器资源的时候，他会向服务器发送一个请求，并且将自己的用户名发给服务器服务器接收到请求的时候，会生成一个16位的随机数（Challenge)，这个随机数有两份，一份返回给客户端，一份留在本地TOM会根据返回的随机数用自己密码的hash值加密随机数，返回给服务器服务器将返回值验证成功后提供服务 域环境下在域环境下就多了一步，因为域环境下服务器域控存储密码hash当服务器收到客户端的返回值的时候，服务器就会向域控发送一个验证请求包域控根据存储的密码hash值对原始challenge进行加密，验证成功性","categories":[],"tags":[]},{"title":"Windows内的kerberos认证","slug":"Windows内的kerberos认证","date":"2019-08-13T08:58:27.000Z","updated":"2019-08-13T09:17:14.392Z","comments":true,"path":"2019/08/13/Windows内的kerberos认证/","link":"","permalink":"http://marblue.me/2019/08/13/Windows内的kerberos认证/","excerpt":"","text":"Windows内的kerberos认证前置知识由于前置知识https://marblue.me/2019/08/13/kerberos认证原理/可以知道，kerberos认证有三个角色：用户、服务、kerberos 在windows里面，kerberos认证主要用在域环境下，于是乎，kerberos认证三个角色就换成了：用户、服务、域控 域控中负责kerberos认证是一个叫KDC（密钥分发中心）的东西，KDC又大致分为三大部分：AS（身份认证服务器），TGS（票据发送服务器），Account Database（账户数据库）在域的创建过程中，会自动创建一个名字叫KRBTGT账号，可以理解成为在KDC中的管理员， 然而kerberos认证只是解决了用户是本人而不是其他人的问题，但是没有解决用户是否有权限访问服务这个问题，为了解决这个问题，微软加入了PAC（特权属性证书）这个概念。 在PAC中包含有两个数字签名PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM，这两个数字签名分别由Server端密码HASH和krtbtgt的 NTLM HASH加密。TGS解密之后验证签名是否正确，然后再重新构造新的PAC放在票据里返回给客户端，客户端将票据发送给服务端进行验证。服务收到票据之后解密得到PAC会将PAC的数字签名发送给KDC，KDC再进行校验然后将结果以RPC返回码的形式返回给服务。 认证流程认证的大致流程kerberos认证的初始理念大致一样，分为三块： 用户与AS的交互 用户与TGS的交互 用户和服务之间的交互 First of All首先，用户输入用户名和密码到Client中，Client会对密码进行特定的处理，这个特定处理之后的值被称为NTLM HASH The Authentication Service Exchange TOM首先发送一个由TOM的NTLM HASH加密的认证包给AS，这个认证包中包含时间戳，TOM的用户名，TOM的网络地址，以及这个包的加密类型 由于KDC中有一个存储着所有用户的NTLM HASH的数据库，AS如果能根据数据库中的NTLM HASH解密TOM发来的认证包，就会返回一个返回包。这个返回包里面有两个内容，一个是由TOM的NTLM HASH加密的口令，另一个是叫做TGT的东西，也就是票据授权票。这个票据授权票由krbtgt的NTLM HASH加密，里面有口令，TOM的信息，TGT的到期时间以及TOM的用户权限 ==注意==：这里的口令指的是TOM与AS间特有的口令 The Ticket-Granting Service (TGS) Exchange TOM收到了AS_T这个返回包之后，用自身的NTLM HASH来解密返回包，获得一个TOM与AS间特有的口令，简称为口令AST，和TGT，当TOM要使用网络上的服务时，TOM就发给TGS一个新的认证包，这个认证包里有两个东西，一个是TGT，另一个是由口令AST加密的包含TOM的信息与时间戳的包。 TGS收到TOM发来的包，首先解密由口令AST加密的包，查看自己的网络是否有TOM请求的服务，如果有，就解密TGT，检查TGT是否过期，TOM的信息是否匹配。 如果验证成功，TGS就会发送返回包TGS_T，TGS_T里面有两个东西，一个是由口令AST加密的TOM和TGT之间特有的口令（简称为口令TGST），另一个就是票据，票据是由服务密码所加密的，里面有口令TGST，用户信息，票据有效期，用户权限，时间戳。 Client/Server Authentication ExchangeTOM发送一个认证包T_S给服务，T_S中包含着两个东西，一个是由口令TGST加密的时间戳，还有一个就是票据服务收到这个认证包的时候，先解密票据，查看票据是否有效，TOM是否为TOM，然后再把用户权限发给KDC，KDC再返回一个认证结果，如果TOM有权限的话，就返回一个S_T返回包给TOM，并且允许TOM使用服务。该票据就会缓存在TOM的电脑内存中","categories":[],"tags":[]},{"title":"kerberos认证原理","slug":"kerberos认证原理","date":"2019-08-13T08:46:31.000Z","updated":"2019-08-13T08:47:15.104Z","comments":true,"path":"2019/08/13/kerberos认证原理/","link":"","permalink":"http://marblue.me/2019/08/13/kerberos认证原理/","excerpt":"","text":"kerberos认证原理几个约定 人有密码、服务有密码 kerberos中存储着所有人和服务的密码 票据可以重用 大致认证流程Step1主机发送：我要使用邮件服务器kerberos回应：表明身份主机发送TOM（当前使用的用户的用户名）kerberos发回一个由TOM的密码加密的一个包，这个包里面有一个票据授权票这时候TOM在本地输入自己的密码，就可以正确解密包，获得票据授权票 PS. 票据授权票特可以重复使用 Step2TOM申请使用邮件服务，并且将票据授权票给kerberoskerberos返回一个口令和一个邮件服务票据TOM使用口令生成一个由口令加密而成的验证器 Step3TOM把邮件服务票据和验证器发给邮件服务器邮件服务器首先用邮件服务密码解密票据，验证TOM身份和验证票据有效性以及获取口令如果都验证成功，邮件服务器返回一个由口令加密的返回包TOM收到返回包并且使用口令对返回包进行解码，验证是否真的是邮件服务器发回来的返回包，如果是真的，就使用邮件服务","categories":[],"tags":[]}]}